\Chapter{Integrált fejlesztőkörnyezet}

% TODO: Fel kell sorolni, hogy milyen részekből épül fel egy fejlesztőkörnyezet, milyen funkciókat tartalmaz!

% TODO: Ki kell külön térni a bővíthetőségére, személyreszabhatóságára!

% TODO: Specifikálni kell az elkészítendő szoftvert!

Ahhoz, hogy egy felhasználó-barát fejlesztőkörnyezetet készítsünk, fontos, hogy ne feledjük, hogy egy \emph{környezetet} készítünk: azaz, az IDE-nek magában kell, hogy foglaljon mindent, ami szükséges lehet szoftverfejlesztéshez Rust-ban, legalább a standard könyv\-tár kezelése során. Ebből következőleg az IDE fő célja az kell, hogy legyen, hogy a felhasználónak a lehető legkevesebbet kelljen az fejlesztői környezetét elhagyni -- ha valamit szükséges neki megtenni, akkor azt fontos, hogy az IDE-n keresztül, illetve annak segítségével, tudja véghezvinni. Ilyen környezeten kívüli elkerülendő dolgok pél\-dá\-ul a terminál illetve parancssor használata fordításhoz, a dokumentáció megtekintése \texttt{cargo doc}-on keresztül, vagy egy külső verziókövető szoftver használata.

Nyilván a fejlesztőkörnyezet célja nem az, hogy ezeket a segédeszközöket leváltsa -- sőt, az IDE maga ezekkel fog kommunikálni! A specializált szoftver elkerülhetetlenül többre lesz képes, mint a generalizált IDE, így a magasabb képességű programozó igényeit nem feltétlenül fogja kiszolgálni csak az IDE maga, viszont az átlagos prog\-ra\-mo\-zó szempontjából célszerű az, hogy a fejlesztés a lehető legkevesebb gondolatbeli kontextus-váltással járjon.

Az IDE céljait behatárolva felsorolhatjuk, hogy mire kell, hogy képes legyen a fejlesztőkörnyezet. A szükséges funkciók a következők:

\begin{itemize}
	\item A forráskódok szerkeszthetőek legyenek az IDE-n belül. Ez talán egy átlagos IDE legalapvetőbb követelménye. Elégséges az, hogy ha egyszerre egy fájlt tudunk megnyitni. Fontos itt a Rust nyelv kulcsszavainak kiemelése színezéssel és fél\-kö\-vé\-re\-sí\-tés\-sel, az automatikus zárójel-kiegészítés (ha \texttt{(}-et kezdünk, akkor a program automatikusan beillessze a megfelelő \texttt{)}-et is), illetve -összekapcsolás (a program ki kell, hogy emelje, hogy egy zárójelnek hol a párja).
	
	\item Kapcsolódva a fenti ponthoz, az IDE-nek szükséges kódjavaslatokat feltenni a felhasználónak, mind új kód írásakor, és régi kód javításakor. Mint a legtöbb nyelvben, a Rust-ban is létezik egy \emph{nyelvszerver}, a \emph{Rust Language Server}\cite{rls}. A nyelvszerver szerepe pontosan ez, így szükséges lesz kommunikáció kiépítése az \emph{RLS}-sel. Ha valamiért ez nem sikerülne, akkor mi magunk is megoldhatunk egy hasonló funkciót a fordítóprogram és a \emph{racer}\cite{racer} segítségével -- az RLS maga is ezt csinálja. Ennek ellenére preferáltabb az RLS-sel dolgozó megoldás.
	
	\item Az IDE tudjon elvégezni lintelést, illetve projektformázási javaslatokat. Az előbbi megvalósítható a \texttt{clippy}\cite{clippy} program segítségével, az utóbbi a \texttt{rustfmt}\cite{rustfmt} prog\-ram\-mal.
	
	\item Szükséges, hogy a felhasználó tudja a projekthez kapcsolatos fájlok kezelését az IDE-n belülről. Ez alatt az is értetendő, hogy a felhasználó létre tudjon hozni cargo projekteket az IDE-n keresztül, illetve hogy be tudjon tölteni régi cargo projekteket az IDE-be. Fontos, hogy csak az számítson, hogy a betöltött projekt cargo-val lett létrehozva, ne az, hogy az IDE által. Az IDE tárolhat információkat a projektról egy rejtett mappában, de ne legyen kötelező a projekt módosításához. Továbbá, az IDE-n belül fontos, hogy legyen a projekt fáljrendszerének egy fa-struktúrás reprezentációja, ami segítségével a felhasználó tudjon refaktorálást végezni a fájlokon, vagy a cargo követelményeit betartva hozhasson létre fájlokat (A Rust 2016-os verziója például megköveteli, hogy a modulmappák 'fő' for\-rás\-fájl\-ja a \texttt{mod.rs} nevet kapja).
	
	\item Az IDE tudja a projektet megépíteni debuggoláshoz és kiadáshoz, tudja a projekt tesztjeit lefuttatni, és tudja a projekt problémáit leellenőrzni. Ezek viszonylag egyszerű cargo parancsmeghívások, a fontos rész az, hogy ezeket a felhasználó egy gombnyomással vagy billentyűkombinációval meg tudja hívni.
	
	\item Az IDE tudjon dokumentációt szolgáltatni a felhasználónak a kód megadott részeiről. Ez a funkció valójában három különböző szinten kell, hogy létezzen:
	\begin{enumerate}
		\item A kódszerkesztés közben az IDE-nek magyarázatot kell szolgáltatni az éppen fókuszban lévő kódrészletről. Funkció esetén a funkció paramétereiről és visszatérési értékeiről, struktúra esetén a publikus mezőkről, illetve mind\-ket\-tő esetén egy rövid leírást kell szolgáltatnia róla.
		
		\item A felhasználó külön kérésére az IDE-nek meg kell nyitnia a megadott kód\-rész\-let\-hez kapcsolódó dokumentációt, ha létezik. Rust-ban szokás \texttt{cargo doc} segítségével weblap-alapú dokumentáció készítése, így az IDE-nek a háttérben kötelező a dokumentációt legenerálnia, és a megadott weblapot renderelnie magán belül.
		
		\item Ha a felhasználó ezen kívül szeretne dokumentációt olvasni, akkor ezeket az IDE jelenítse meg a felhasználó megadott webböngészőjében. Ezt a lépést tekinthetjük túl specializáltnak az IDE-hez.
	\end{enumerate}
	
	\item Az IDE-nek szolgáltatnia kell alapvető verziókövetési támogatást. Mivel a git a legelterjettebb verziókövető alkalmazás, ezért az IDE-nek tudnia kell git által változtatásokat feltölteni, letölteni, commit-olni, ágakat létrehozni.
	
	\item Végül, ha szükséges, az IDE legyen bővíthető. Hasonlóképpen a \emph{Visual Studio}-hoz, legyen lehetőség saját parancsok létrehozására, amikkel a felhasználó tet\-sző\-le\-ges programokat hívhat meg. Ezeket a kényelem kedvéért az IDE beillesztheti egy menübe, így a parancs meghívása nem igényelne, csak néhány kattintást.
\end{itemize}